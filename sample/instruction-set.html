<HTML><HEAD><TITLE>AcheronVM Instruction Set</TITLE></HEAD><BODY STYLE="margin:0 2em"><H1>AcheronVM - Instruction Set</H1><P><I>The file was automatically generated by Acheron VM build tools</I><BR/></P><H2>Contents</H2><UL><LI><A HREF="#0">Naming Conventions</A></LI><LI><A HREF="#1">Register and Stack Operations</A></LI><LI><A HREF="#2">Flow Control</A></LI><LI><A HREF="#3">Bitwise Operations</A></LI><LI><A HREF="#4">Arithmetic</A></LI><LI><A HREF="#5">Memory Operations</A></LI><LI><A HREF="#6">Global Variables (FEATURE__GLOBALS)</A></LI><LI><A HREF="#7">Exception Handling (FEATURE__EXCEPTIONS)</A></LI><LI><A HREF="#8">Monitor Traps (FEATURE__TRAPS)</A></LI><LI><A HREF="#9">Data Frames (FEATURE__DATAFRAMES)</A></LI></UL><HR/><A NAME="0"><H2>Naming Conventions</H2></A><BLOCKQUOTE><TABLE><TR><TD WIDTH=70><CODE><B>r0-r127</B></CODE></TD><TD WIDTH=20/><TD>The registers currently visible in the register window.  r0 is always the head of the register stack.</TD></TR><TR><TD WIDTH=70><CODE><B>rP</B></CODE></TD><TD WIDTH=20/><TD>The remembered Prior register, rD from the last instruction that used one (including 'with <i>rD</i>'). Acts like an implicit accumulator.</TD></TR><TR><TD WIDTH=70><CODE><B>rP:r[P+1]</B></CODE></TD><TD WIDTH=20/><TD>32-bit effective register, with rP being the low word and the next register in memory being the high word.</TD></TR><TR><TD WIDTH=70><CODE><B>rD</B></CODE></TD><TD WIDTH=20/><TD>A numbered register operand for data or destination, which will become the new rP after the instruction completes.</TD></TR><TR><TD WIDTH=70><CODE><B>rA</B></CODE></TD><TD WIDTH=20/><TD>A numbered register operand for auxiliary/address use by the instruction.</TD></TR><TR><TD WIDTH=70><CODE><B>imm8</B></CODE></TD><TD WIDTH=20/><TD>8-bit immediate value, representing 0-255.</TD></TR><TR><TD WIDTH=70><CODE><B>imm8p</B></CODE></TD><TD WIDTH=20/><TD>8-bit immediate value, representing 1-256.</TD></TR><TR><TD WIDTH=70><CODE><B>imm16</B></CODE></TD><TD WIDTH=20/><TD>16-bit immediate value, 0-65535.</TD></TR><TR><TD WIDTH=70><CODE><B>rel8</B></CODE></TD><TD WIDTH=20/><TD>Used in branches, a target address which is within an 8-bit signed range of bytes from the first byte of the instruction.  A branch to a rel8-encoded $00 loops back to the branch instruction itself.</TD></TR><TR><TD WIDTH=70><CODE><B>:=</B></CODE></TD><TD WIDTH=20/><TD>Assignment</TD></TR></TABLE></BLOCKQUOTE><HR/><H3>Number of Instruction Opcodes Used: 115</H3><HR/><H2 ID="1">Register and Stack Operations</H2><P>The mark for the register stack set by mgrow is put on the CPU stack.  It does not affect any registers and marks can nest.</P><BLOCKQUOTE><P><B><U>Instructions</U></B><TABLE><TR><TD><B><PRE>clrp</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>rP := 0</TD></TR><TR><TD><B><PRE>copyr</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>rP := rA.  Copy another register into rP.</TD></TR><TR><TD><B><PRE>dropp</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Drop a 16-bit value from the CPU stack.</TD></TR><TR><TD><B><PRE>getsp</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>rP := CPU stack pointer</TD></TR><TR><TD><B><PRE>grow</PRE></B></TD><TD><I><PRE> imm8</PRE></I></TD><TD WIDTH=20/><TD>Grow the register stack by imm8 slots.  rP is unchanged.</TD></TR><TR><TD><B><PRE>ldrptr</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>rP := current address of rA.  Note that task switching or otherwise swapping out zp can leave this pointer dangling.</TD></TR><TR><TD><B><PRE>mgrow</PRE></B></TD><TD><I><PRE> imm8</PRE></I></TD><TD WIDTH=20/><TD>Push a mark of the register stack, and grow it by imm8 slots.  rP is unchanged.</TD></TR><TR><TD><B><PRE>movep</PRE></B></TD><TD><I><PRE> rD</PRE></I></TD><TD WIDTH=20/><TD>rD := rP.  Effectively move rP and its value to another register.</TD></TR><TR><TD><B><PRE>popp</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Pop rP from the CPU stack.</TD></TR><TR><TD><B><PRE>pushp</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Push rP to the CPU stack.</TD></TR><TR><TD><B><PRE>setp16</PRE></B></TD><TD><I><PRE> imm16</PRE></I></TD><TD WIDTH=20/><TD>rP := imm16</TD></TR><TR><TD><B><PRE>setp8</PRE></B></TD><TD><I><PRE> imm8</PRE></I></TD><TD WIDTH=20/><TD>rP := imm8</TD></TR><TR><TD><B><PRE>setsp</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>CPU stack pointer := rP.  Only the low byte is used.</TD></TR><TR><TD><B><PRE>shrink</PRE></B></TD><TD><I><PRE> imm8</PRE></I></TD><TD WIDTH=20/><TD>Shrink the register stack by imm8 slots.  The resulting r0 becomes the new rP.</TD></TR><TR><TD><B><PRE>shrinkm</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Shrink the register stack to last mark, and pop it.  The resulting r0 becomes the new rP.</TD></TR></TABLE></P><P><B><U>Pseudo Instructions</U></B><TABLE><TR><TD><B><CODE>setp</CODE></B></TD><TD><I><CODE>imm</CODE></I></TD><TD WIDTH=10/><TD>Becomes clrp, setp8, or setp16.</TD></TR></TABLE></P><P><B><U>Native Routines</U></B><TABLE><TR><TD><PRE>jsr <B>clear_rstack</B></PRE></TD><TD WIDTH=20/><TD>Initializes an empty register stack.  This is the minimum initialization needed for basic test code, but note that other features may not be initialized (globals, dataframes, etc).</TD></TR></TABLE></P><P><B><U>Zeropage Locations</U></B><TABLE><TR><TD><B><CODE>zpTop:</CODE></B></TD><TD><PRE> .res 0</PRE></TD><TD WIDTH=20/><TD>Highest zeropage memory location in use, for copying out process context.</TD></TR><TR><TD><B><CODE>rptr:</CODE></B></TD><TD><PRE> .res 1</PRE></TD><TD WIDTH=20/><TD>Pointer to the head of the register stack, which is also r0, and the lowest used byte in zp.</TD></TR><TR><TD><B><CODE>pptr:</CODE></B></TD><TD><PRE> .res 1</PRE></TD><TD WIDTH=20/><TD>Pointer to the prior register, rP.</TD></TR><TR><TD><B><CODE>rstackTop:</CODE></B></TD><TD><PRE> .res 0</PRE></TD><TD WIDTH=20/><TD>The memory location right after the register stack.  This is the value of rptr when the register stack is empty.</TD></TR></TABLE></P></BLOCKQUOTE><HR/><H2 ID="2">Flow Control</H2><P>
To call an Acheron subroutine from native code:<pre> jsr acheron
 call <i>label</i>
 native</pre>This supports reentrant usage from within native portions of a running Acheron call chain.</P><BLOCKQUOTE><P><B><U>Instructions</U></B><TABLE><TR><TD><B><PRE>ba</PRE></B></TD><TD><I><PRE> rel8</PRE></I></TD><TD WIDTH=20/><TD>Always branch.</TD></TR><TR><TD><B><PRE>bc</PRE></B></TD><TD><I><PRE> rel8</PRE></I></TD><TD WIDTH=20/><TD>Pop a carry bit, branch if it is set.</TD></TR><TR><TD><B><PRE>bnc</PRE></B></TD><TD><I><PRE> rel8</PRE></I></TD><TD WIDTH=20/><TD>Pop a carry bit, branch if it is clear.</TD></TR><TR><TD><B><PRE>bneg</PRE></B></TD><TD><I><PRE> rel8</PRE></I></TD><TD WIDTH=20/><TD>Branch if rP is negative.</TD></TR><TR><TD><B><PRE>bnz</PRE></B></TD><TD><I><PRE> rel8</PRE></I></TD><TD WIDTH=20/><TD>Branch if rP is non-zero.</TD></TR><TR><TD><B><PRE>bpos</PRE></B></TD><TD><I><PRE> rel8</PRE></I></TD><TD WIDTH=20/><TD>Branch if rP is non-negative.</TD></TR><TR><TD><B><PRE>bz</PRE></B></TD><TD><I><PRE> rel8</PRE></I></TD><TD WIDTH=20/><TD>Branch if rP is zero.</TD></TR><TR><TD><B><PRE>call</PRE></B></TD><TD><I><PRE> imm16</PRE></I></TD><TD WIDTH=20/><TD>Call subroutine at imm16.</TD></TR><TR><TD><B><PRE>calln</PRE></B></TD><TD><I><PRE> imm16</PRE></I></TD><TD WIDTH=20/><TD>Call native 6502 subroutine at imm16.  .X points to rP.  .X and .Y are saved and restored.</TD></TR><TR><TD><B><PRE>callp</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Call subroutine at the address held in rP.</TD></TR><TR><TD><B><PRE>case16</PRE></B></TD><TD><I><PRE> imm16, rel8</PRE></I></TD><TD WIDTH=20/><TD>Branch if rP = imm16.</TD></TR><TR><TD><B><PRE>case8</PRE></B></TD><TD><I><PRE> imm8, rel8</PRE></I></TD><TD WIDTH=20/><TD>Branch if rP = imm8.</TD></TR><TR><TD><B><PRE>caser</PRE></B></TD><TD><I><PRE> rA, rel8</PRE></I></TD><TD WIDTH=20/><TD>Branch if rP = rA</TD></TR><TR><TD><B><PRE>decloop</PRE></B></TD><TD><I><PRE> rel8neg</PRE></I></TD><TD WIDTH=20/><TD>Decrements rP by r[P+1], looping back 0-255 bytes if it hasn't underflowed yet.</TD></TR><TR><TD><B><PRE>decloopi</PRE></B></TD><TD><I><PRE> imm8, rel8neg</PRE></I></TD><TD WIDTH=20/><TD>Decrements rP by imm8, looping back imm8 bytes if it hasn't underflowed yet.</TD></TR><TR><TD><B><PRE>jump</PRE></B></TD><TD><I><PRE> imm16</PRE></I></TD><TD WIDTH=20/><TD>Jump to imm16.</TD></TR><TR><TD><B><PRE>jumpp</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Jump to address held in rP.</TD></TR><TR><TD><B><PRE>native</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Enter 6502 mode, starting at the byte after this instruction.</TD></TR><TR><TD><B><PRE>noop</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>No operation.</TD></TR><TR><TD><B><PRE>ret</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Return from subroutine.</TD></TR><TR><TD><B><PRE>retm</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Pop & restore the register stack mark from mgrow, return from subroutine.  Resets rP to the returned r0.</TD></TR></TABLE></P><P><B><U>Pseudo Instructions</U></B><TABLE><TR><TD><B><CODE>case</CODE></B></TD><TD><I><CODE>imm, rel8</CODE></I></TD><TD WIDTH=10/><TD>Becomes case8 or case16</TD></TR></TABLE></P><P><B><U>Native Routines</U></B><TABLE><TR><TD><PRE>jsr <B>acheronNest</B></PRE></TD><TD WIDTH=20/><TD>Enter Acheron mode as if called as a subroutine, interpreting bytecodes immediately after the JSR instruction.  When this code ret's, the prior running Acheron code will resume.</TD></TR><TR><TD><PRE>jsr <B>acheron</B></PRE></TD><TD WIDTH=20/><TD>Enter Acheron mode, interpreting bytecodes immediately after the JSR instruction.</TD></TR></TABLE></P><P><B><U>Zeropage Locations</U></B><TABLE><TR><TD><B><CODE>iptr:</CODE></B></TD><TD><PRE> .res 2</PRE></TD><TD WIDTH=20/><TD>Instruction pointer base.  This plus .Y addresses the current program byte.  The dispatcher keeps .Y in the range of 0 to 127, so overflow after INY does not need to be checked.</TD></TR><TR><TD><B><CODE>iptr_offset:</CODE></B></TD><TD><PRE> .res 1</PRE></TD><TD WIDTH=20/><TD>Temp storage for the .Y offset to iptr when using the register for other purposes.</TD></TR></TABLE></P></BLOCKQUOTE><HR/><H2 ID="3">Bitwise Operations</H2><BLOCKQUOTE><P><B><U>Instructions</U></B><TABLE><TR><TD><B><PRE>addea2</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>rP := rP + (rA << 1).  Does not affect carry.</TD></TR><TR><TD><B><PRE>andi</PRE></B></TD><TD><I><PRE> imm16</PRE></I></TD><TD WIDTH=20/><TD>rP := rP & imm16</TD></TR><TR><TD><B><PRE>andr</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>rP := rP & rA</TD></TR><TR><TD><B><PRE>bswap</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Swap high and low bytes of rP.</TD></TR><TR><TD><B><PRE>dropc</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Discard the most recent carry bit.</TD></TR><TR><TD><B><PRE>dupc</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Duplicate the top carry bit.</TD></TR><TR><TD><B><PRE>flipc</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Flip the state of the most recent carry bit, leaving it on the carry stack.</TD></TR><TR><TD><B><PRE>fromhex</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Convert rP from a 2-byte ASCII hex representation into an 8-bit value.  This operation is case-insensitive.</TD></TR><TR><TD><B><PRE>hibyte</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>rP := upper byte of rP.</TD></TR><TR><TD><B><PRE>lobyte</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>rP := lower byte of rP.</TD></TR><TR><TD><B><PRE>not</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>rP := rP ^ $ffff</TD></TR><TR><TD><B><PRE>nswap</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Swap nybbles of the low byte of rP.</TD></TR><TR><TD><B><PRE>ori</PRE></B></TD><TD><I><PRE> imm16</PRE></I></TD><TD WIDTH=20/><TD>rP := rP | imm16</TD></TR><TR><TD><B><PRE>orr</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>rP := rP | rA</TD></TR><TR><TD><B><PRE>pushcc</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Push a clear carry bit.</TD></TR><TR><TD><B><PRE>pushcs</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Push a set carry bit.</TD></TR><TR><TD><B><PRE>roll</PRE></B></TD><TD><I><PRE> imm8</PRE></I></TD><TD WIDTH=20/><TD>rP := (rP << imm8) | (rP >> (16 - imm8)), imm8 is nonzero.</TD></TR><TR><TD><B><PRE>shl</PRE></B></TD><TD><I><PRE> imm8</PRE></I></TD><TD WIDTH=20/><TD>rP := rP << imm8 (nonzero), bits shift into the carry stack.</TD></TR><TR><TD><B><PRE>shr</PRE></B></TD><TD><I><PRE> imm8</PRE></I></TD><TD WIDTH=20/><TD>rP := rP >> imm8 (nonzero), bits shift into the carry stack.</TD></TR><TR><TD><B><PRE>signx</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Sign extend an 8-bit value in rP into 16 bits.</TD></TR><TR><TD><B><PRE>sshr</PRE></B></TD><TD><I><PRE> imm8</PRE></I></TD><TD WIDTH=20/><TD>rP := rP >>> imm8 (nonzero), bits shift into the carry stack.</TD></TR><TR><TD><B><PRE>tohex</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Convert rP into a 2-byte ASCII hex representation of its low byte, e.g. $00f1 => $3146 (little endian, so 'f1').</TD></TR><TR><TD><B><PRE>xori</PRE></B></TD><TD><I><PRE> imm16</PRE></I></TD><TD WIDTH=20/><TD>rP := rP ^ imm16</TD></TR><TR><TD><B><PRE>xorr</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>rP := rP ^ rA</TD></TR></TABLE></P></BLOCKQUOTE><HR/><H2 ID="4">Arithmetic</H2><BLOCKQUOTE><P><B><U>Instructions</U></B><TABLE><TR><TD><B><PRE>add</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>rP := rP + rA</TD></TR><TR><TD><B><PRE>addc</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>rP := rP + rA + carry</TD></TR><TR><TD><B><PRE>addi16</PRE></B></TD><TD><I><PRE> imm16</PRE></I></TD><TD WIDTH=20/><TD>rP := rP + imm16</TD></TR><TR><TD><B><PRE>addi16c</PRE></B></TD><TD><I><PRE> imm16</PRE></I></TD><TD WIDTH=20/><TD>rP := rP + imm16 + carry</TD></TR><TR><TD><B><PRE>addi8</PRE></B></TD><TD><I><PRE> imm8p</PRE></I></TD><TD WIDTH=20/><TD>rP := rP + imm8 (1-256)</TD></TR><TR><TD><B><PRE>addi8c</PRE></B></TD><TD><I><PRE> imm8p</PRE></I></TD><TD WIDTH=20/><TD>rP := rP + imm8 (1-256) + carry</TD></TR><TR><TD><B><PRE>cmpi16</PRE></B></TD><TD><I><PRE> imm16</PRE></I></TD><TD WIDTH=20/><TD>Compare rP - imm16 and push carry result on stack, without affecting registers</TD></TR><TR><TD><B><PRE>cmpi8</PRE></B></TD><TD><I><PRE> imm8</PRE></I></TD><TD WIDTH=20/><TD>Compare rP - imm8 and push carry result on stack, without affecting registers</TD></TR><TR><TD><B><PRE>cmpr</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>Compare rP - rA and push carry result on stack, without affecting registers (0: rP&lt;rA, 1: rP&gt;=rA)</TD></TR><TR><TD><B><PRE>decp</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>rP := rP - 1</TD></TR><TR><TD><B><PRE>decp2</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>rP := rP - 2</TD></TR><TR><TD><B><PRE>div</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>rP := quotient, r[P+1] := remainder, of rP/rA.</TD></TR><TR><TD><B><PRE>incp</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>rP := rP + 1</TD></TR><TR><TD><B><PRE>incp2</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>rP := rP + 2</TD></TR><TR><TD><B><PRE>ldiv</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>rP := quotient, r[P+1] := remainder, of rP:r[P+1]/rA.</TD></TR><TR><TD><B><PRE>mac</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>rP:r[P+1] := rP * rA + r[P+1]</TD></TR><TR><TD><B><PRE>mul</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>rP:r[P+1] := rP * rA</TD></TR><TR><TD><B><PRE>negate</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>rP := -rP</TD></TR><TR><TD><B><PRE>sub</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>rP := rP - rA</TD></TR><TR><TD><B><PRE>subc</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>rP := rP - rA - borrow</TD></TR><TR><TD><B><PRE>subi8</PRE></B></TD><TD><I><PRE> imm8p</PRE></I></TD><TD WIDTH=20/><TD>rP := rP - imm8 (1-256)</TD></TR><TR><TD><B><PRE>subi8c</PRE></B></TD><TD><I><PRE> imm8p</PRE></I></TD><TD WIDTH=20/><TD>rP := rP - imm8 (1-256) - borrow</TD></TR></TABLE></P><P><B><U>Pseudo Instructions</U></B><TABLE><TR><TD><B><CODE>addi</CODE></B></TD><TD><I><CODE>imm</CODE></I></TD><TD WIDTH=10/><TD>Becomes addi8, addi16, or subi8.</TD></TR><TR><TD><B><CODE>addic</CODE></B></TD><TD><I><CODE>imm</CODE></I></TD><TD WIDTH=10/><TD>Becomes addi8c, addi16c, or subi8c.</TD></TR><TR><TD><B><CODE>subi</CODE></B></TD><TD><I><CODE>imm</CODE></I></TD><TD WIDTH=10/><TD>Becomes subi8, addi16, or addi8.</TD></TR><TR><TD><B><CODE>subic</CODE></B></TD><TD><I><CODE>imm</CODE></I></TD><TD WIDTH=10/><TD>Becomes subi8c, addi16c, or addi8c.</TD></TR></TABLE></P><P><B><U>Zeropage Locations</U></B><TABLE><TR><TD><B><CODE>cstack:</CODE></B></TD><TD><PRE> .res 1</PRE></TD><TD WIDTH=20/><TD>Carry stack.  MSB is the current carry bit.</TD></TR></TABLE></P></BLOCKQUOTE><HR/><H2 ID="5">Memory Operations</H2><P>Indexed modes take immediate constants, and are intended to reference structure slots without modifying the base pointer. Traversing through memory in order would instead use incp/decp or add/sub instructions on the address register.</P><P>Indexing uses (zp),y addressing behind the scenes, so is limited to +255. Referencing 16-bit data at an index of 255 will wrap to an index of 0 for the high byte and probably break things.</P><P>Memory stores keep rP pointing at the data register, so the destination address should be computed before the value to store into it.</P><P>Note that ldm commands will not work to load into rP.  Use deref instead.</P><BLOCKQUOTE><P><B><U>Instructions</U></B><TABLE><TR><TD><B><PRE>clrm</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>memory(rP) := 0</TD></TR><TR><TD><B><PRE>clrmb</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>memory(rP) byte := 0</TD></TR><TR><TD><B><PRE>clrmn</PRE></B></TD><TD><I><PRE> imm8p</PRE></I></TD><TD WIDTH=20/><TD>memory(rP .. rP+imm8-1) := 0. Clears 1-256 bytes of memory, starting at rP.</TD></TR><TR><TD><B><PRE>deref</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>rP := memory(rP)</TD></TR><TR><TD><B><PRE>derefb</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>rP := memory(rP) byte</TD></TR><TR><TD><B><PRE>derefbi</PRE></B></TD><TD><I><PRE> imm8</PRE></I></TD><TD WIDTH=20/><TD>rP := memory(rP + imm8) byte</TD></TR><TR><TD><B><PRE>derefi</PRE></B></TD><TD><I><PRE> imm8</PRE></I></TD><TD WIDTH=20/><TD>rP := memory(rP + imm8)</TD></TR><TR><TD><B><PRE>ldm</PRE></B></TD><TD><I><PRE> rD</PRE></I></TD><TD WIDTH=20/><TD>rD := memory(rP)</TD></TR><TR><TD><B><PRE>ldma</PRE></B></TD><TD><I><PRE> imm16</PRE></I></TD><TD WIDTH=20/><TD>rP := memory(imm16)</TD></TR><TR><TD><B><PRE>ldmb</PRE></B></TD><TD><I><PRE> rD</PRE></I></TD><TD WIDTH=20/><TD>rD := memory(rP) byte</TD></TR><TR><TD><B><PRE>ldmba</PRE></B></TD><TD><I><PRE> imm16</PRE></I></TD><TD WIDTH=20/><TD>rP := memory(imm16) byte</TD></TR><TR><TD><B><PRE>ldmbi</PRE></B></TD><TD><I><PRE> rD, imm8</PRE></I></TD><TD WIDTH=20/><TD>rD := memory(rP + imm8) byte</TD></TR><TR><TD><B><PRE>ldmbr</PRE></B></TD><TD><I><PRE> rD, rA</PRE></I></TD><TD WIDTH=20/><TD>rD := memory(rP + rA) byte.  Load Memory Byte, Register indexed.</TD></TR><TR><TD><B><PRE>ldmi</PRE></B></TD><TD><I><PRE> rD, imm8</PRE></I></TD><TD WIDTH=20/><TD>rD := memory(rP + imm8)</TD></TR><TR><TD><B><PRE>ldmr</PRE></B></TD><TD><I><PRE> rD, rA</PRE></I></TD><TD WIDTH=20/><TD>rD := memory(rP + rA). Load Memory, Register indexed.</TD></TR><TR><TD><B><PRE>stm</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>memory(rA) := rP.</TD></TR><TR><TD><B><PRE>stma</PRE></B></TD><TD><I><PRE> imm16</PRE></I></TD><TD WIDTH=20/><TD>memory(imm16) := rP</TD></TR><TR><TD><B><PRE>stmb</PRE></B></TD><TD><I><PRE> rA</PRE></I></TD><TD WIDTH=20/><TD>memory(rA) byte := rP.</TD></TR><TR><TD><B><PRE>stmba</PRE></B></TD><TD><I><PRE> imm16</PRE></I></TD><TD WIDTH=20/><TD>memory(imm16) byte := rP</TD></TR><TR><TD><B><PRE>stmbi</PRE></B></TD><TD><I><PRE> rA, imm8</PRE></I></TD><TD WIDTH=20/><TD>memory(rA + imm8) byte := rP.</TD></TR><TR><TD><B><PRE>stmbr</PRE></B></TD><TD><I><PRE> rD, rA</PRE></I></TD><TD WIDTH=20/><TD>memory(rD + rA) byte := rP.  Store Memory Byte, Register indexed.</TD></TR><TR><TD><B><PRE>stmi</PRE></B></TD><TD><I><PRE> rA, imm8</PRE></I></TD><TD WIDTH=20/><TD>memory(rA + imm8) := rP.</TD></TR><TR><TD><B><PRE>stmr</PRE></B></TD><TD><I><PRE> rD, rA</PRE></I></TD><TD WIDTH=20/><TD>memory(rD + rA) := rP.  Store Memory, Register indexed.</TD></TR></TABLE></P></BLOCKQUOTE><HR/><H2 ID="6">Global Variables (FEATURE__GLOBALS)</H2><P>Similar to the 6502's zeropage, 256 bytes of global storage (as opposed to register stack storage) are addressable in short form.</P><P>Dereferencing through gptr allows faster context switching and reusable code between processes with different global tables.</P><BLOCKQUOTE><P><B><U>Instructions</U></B><TABLE><TR><TD><B><PRE>getgptr</PRE></B></TD><TD><I><PRE> imm8</PRE></I></TD><TD WIDTH=20/><TD>rP := pointer to global(rP)</TD></TR><TR><TD><B><PRE>ldg</PRE></B></TD><TD><I><PRE> imm8</PRE></I></TD><TD WIDTH=20/><TD>rP := global(imm8)</TD></TR><TR><TD><B><PRE>stg</PRE></B></TD><TD><I><PRE> imm8</PRE></I></TD><TD WIDTH=20/><TD>global(imm8) := rP</TD></TR></TABLE></P><P><B><U>Zeropage Locations</U></B><TABLE><TR><TD><B><CODE>gptr:</CODE></B></TD><TD><PRE> .res 2</PRE></TD><TD WIDTH=20/><TD>Pointer to the globals area.  Must be directly initialized before use.</TD></TR></TABLE></P></BLOCKQUOTE><HR/><H2 ID="7">Exception Handling (FEATURE__EXCEPTIONS)</H2><P>These are non-local returns that can also be used for error handling.</P><P>When a throw is triggered, the CPU and register stacks are restored to the state at the time of the catch, the register stack grows by 2 slots, and r0 & r1 become the exception tag and parameter, respectively, with rP pointing to r0. Usually a handler will use 'case' instructions to branch on desired tags, rethrowing the exception otherwise.</P><P>For handling 'finally' situations, normal code flow and exception rethrowing need to be handled in the same code:</P><P>
<pre>  catch finally
  ...
  popcatch     ; normal fallthrough into the 'finally' clause
  grow 2
  with r0 clrp
finally:
  ...
  throw r0,r1  ; ignored if no exception was thrown and r0 is still zero</pre></P><P>Each catch context takes 5 bytes on the CPU stack.</P><BLOCKQUOTE><P><B><U>Instructions</U></B><TABLE><TR><TD><B><PRE>catch</PRE></B></TD><TD><I><PRE> imm16</PRE></I></TD><TD WIDTH=20/><TD>Register an exception handler routine at imm16, with rP:r[P+1] receiving the exception info.</TD></TR><TR><TD><B><PRE>popcatch</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Discard the most recent exception handler.</TD></TR><TR><TD><B><PRE>throw</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>If rP is nonzero, throw an exception with tag rP and parameter r[P+1].  Can be used to rethrow from inside a catch handler.</TD></TR></TABLE></P><P><B><U>Zeropage Locations</U></B><TABLE><TR><TD><B><CODE>currentCatch:</CODE></B></TD><TD><PRE> .res 1</PRE></TD><TD WIDTH=20/><TD>CPU stack position describing the currently registered exception handler.</TD></TR></TABLE></P></BLOCKQUOTE><HR/><H2 ID="8">Monitor Traps (FEATURE__TRAPS)</H2><P>The trap system allows breaking into native code before each instruction is executed, or when exceptions are thrown.  Native code can then check the iptr for breakpoint matches, resume, single-step, swap tasks, or do whatever it wants.</P><P>When the trap runs, the iptr points to the beginning of the instruction yet to be executed.</P><P>These handlers self-modify the main loop, so there is no runtime overhead when this feature is included and disabled, besides the memory footprint. Since the selfmod happens only on native instruction boundaries, it is safe to enable/disable traps from interrupt handlers. Preemptive task switchers should use this sort of approach.</P><BLOCKQUOTE><P><B><U>Native Routines</U></B><TABLE><TR><TD><PRE>jsr <B>enableInstructionTrap</B></PRE></TD><TD WIDTH=20/><TD>Enable the instruction trap to call <.A >.X.</TD></TR><TR><TD><PRE>jsr <B>disableInstructionTrap</B></PRE></TD><TD WIDTH=20/><TD>Disable the break functionality.</TD></TR><TR><TD><PRE>jmp <B>continueFromInstructionTrap</B></PRE></TD><TD WIDTH=20/><TD>Continue running the VM after a break was triggered.  If the break is still enabled, this effectively single-steps.</TD></TR><TR><TD><PRE>jsr <B>enableExceptionTrap</B></PRE></TD><TD WIDTH=20/><TD>Enable the exception trap to call <.A >.X</TD></TR><TR><TD><PRE>jsr <B>disableExceptionTrap</B></PRE></TD><TD WIDTH=20/><TD>Disable exception trap.</TD></TR><TR><TD><PRE>jmp <B>continueFromExceptionTrap</B></PRE></TD><TD WIDTH=20/><TD>Continue processing the exception thrown.</TD></TR></TABLE></P></BLOCKQUOTE><HR/><H2 ID="9">Data Frames (FEATURE__DATAFRAMES)</H2><BLOCKQUOTE><P><B><U>Instructions</U></B><TABLE><TR><TD><B><PRE>dsalloc</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Allocate rP bytes as a new data stack frame, pushing the old location on the CPU stack.</TD></TR><TR><TD><B><PRE>dsi</PRE></B></TD><TD><I><PRE> imm8</PRE></I></TD><TD WIDTH=20/><TD>rP := pointer to dataframe(imm8)</TD></TR><TR><TD><B><PRE>dspop</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>Discard the most recently allocated data stack frame, restoring state from the CPU stack.</TD></TR><TR><TD><B><PRE>getdsptr</PRE></B></TD><TD><I><PRE> </PRE></I></TD><TD WIDTH=20/><TD>rP = pointer to dataframe(rP)</TD></TR></TABLE></P><P><B><U>Zeropage Locations</U></B><TABLE><TR><TD><B><CODE>dsptr:</CODE></B></TD><TD><PRE> .res 2</PRE></TD><TD WIDTH=20/><TD>Pointer to the dataframe head.  Must be directly initialized before use.</TD></TR></TABLE></P></BLOCKQUOTE></BODY></HTML>
